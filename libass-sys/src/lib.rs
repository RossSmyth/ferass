/* automatically generated by rust-bindgen 0.63.0 */

pub type va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ass_renderer {
    _unused: [u8; 0],
}
pub type ASS_Renderer = ass_renderer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ass_library {
    _unused: [u8; 0],
}
pub type ASS_Library = ass_library;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ass_style {
    pub Name: *mut ::std::os::raw::c_char,
    pub FontName: *mut ::std::os::raw::c_char,
    pub FontSize: f64,
    pub PrimaryColour: u32,
    pub SecondaryColour: u32,
    pub OutlineColour: u32,
    pub BackColour: u32,
    pub Bold: ::std::os::raw::c_int,
    pub Italic: ::std::os::raw::c_int,
    pub Underline: ::std::os::raw::c_int,
    pub StrikeOut: ::std::os::raw::c_int,
    pub ScaleX: f64,
    pub ScaleY: f64,
    pub Spacing: f64,
    pub Angle: f64,
    pub BorderStyle: ::std::os::raw::c_int,
    pub Outline: f64,
    pub Shadow: f64,
    pub Alignment: ::std::os::raw::c_int,
    pub MarginL: ::std::os::raw::c_int,
    pub MarginR: ::std::os::raw::c_int,
    pub MarginV: ::std::os::raw::c_int,
    pub Encoding: ::std::os::raw::c_int,
    pub treat_fontname_as_pattern: ::std::os::raw::c_int,
    pub Blur: f64,
    pub Justify: ::std::os::raw::c_int,
}
pub type ASS_Style = ass_style;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct ass_track {
    pub _bindgen_opaque_blob: [u64; 17usize],
}
pub mod ass_track__bindgen_ty_1 {
    pub type Type = ::std::os::raw::c_int;
    pub const TRACK_TYPE_UNKNOWN: Type = 0;
    pub const TRACK_TYPE_ASS: Type = 1;
    pub const TRACK_TYPE_SSA: Type = 2;
}
pub type ASS_Track = ass_track;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ass_image {
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub stride: ::std::os::raw::c_int,
    pub bitmap: *mut ::std::os::raw::c_uchar,
    pub color: u32,
    pub dst_x: ::std::os::raw::c_int,
    pub dst_y: ::std::os::raw::c_int,
    pub next: *mut ass_image,
    pub type_: ass_image__bindgen_ty_1::Type,
}
pub mod ass_image__bindgen_ty_1 {
    pub type Type = ::std::os::raw::c_int;
    pub const IMAGE_TYPE_CHARACTER: Type = 0;
    pub const IMAGE_TYPE_OUTLINE: Type = 1;
    pub const IMAGE_TYPE_SHADOW: Type = 2;
}
pub type ASS_Image = ass_image;
pub mod ASS_Hinting {
    pub type Type = ::std::os::raw::c_int;
    pub const ASS_HINTING_NONE: Type = 0;
    pub const ASS_HINTING_LIGHT: Type = 1;
    pub const ASS_HINTING_NORMAL: Type = 2;
    pub const ASS_HINTING_NATIVE: Type = 3;
}
pub mod ASS_ShapingLevel {
    #[doc = " \\brief Text shaping levels.\n\n SIMPLE is a fast, font-agnostic shaper that can do only substitutions.\n COMPLEX is a slower shaper using OpenType for substitutions and positioning.\n\n libass uses the best shaper available by default."]
    pub type Type = ::std::os::raw::c_int;
    pub const ASS_SHAPING_SIMPLE: Type = 0;
    pub const ASS_SHAPING_COMPLEX: Type = 1;
}
extern "C" {
    #[doc = " \\brief Return the version of library. This returns the value LIBASS_VERSION\n was set to when the library was compiled.\n \\return library version"]
    pub fn ass_library_version() -> ::std::os::raw::c_int;
}
pub mod ASS_DefaultFontProvider {
    #[doc = " \\brief Default Font provider to load fonts in libass' database\n\n NONE don't use any default font provider for font lookup\n AUTODETECT use the first available font provider\n CORETEXT force a CoreText based font provider (OS X only)\n DIRECTWRITE force a DirectWrite based font provider (Microsoft Win32 only)\n FONTCONFIG force a Fontconfig based font provider\n\n libass uses the best shaper available by default."]
    pub type Type = ::std::os::raw::c_int;
    pub const ASS_FONTPROVIDER_NONE: Type = 0;
    pub const ASS_FONTPROVIDER_AUTODETECT: Type = 1;
    pub const ASS_FONTPROVIDER_CORETEXT: Type = 2;
    pub const ASS_FONTPROVIDER_FONTCONFIG: Type = 3;
    pub const ASS_FONTPROVIDER_DIRECTWRITE: Type = 4;
}
pub mod ASS_Feature {
    pub type Type = ::std::os::raw::c_int;
    #[doc = " Enable libass extensions that would display ASS subtitles incorrectly.\n These may be useful for applications, which use libass as renderer for\n subtitles converted from another format, or which use libass for other\n purposes that do not involve actual ASS subtitles authored for\n distribution."]
    pub const ASS_FEATURE_INCOMPATIBLE_EXTENSIONS: Type = 0;
    #[doc = " Match bracket pairs in bidirectional text according to the revised\n Unicode Bidirectional Algorithm introduced in Unicode 6.3.\n This is incompatible with VSFilter and disabled by default.\n\n (Directional isolates, also introduced in Unicode 6.3,\n are unconditionally processed when FriBidi is new enough.)\n\n This feature may be unavailable at runtime (ass_track_set_feature\n may return -1) if libass was compiled against old FriBidi."]
    pub const ASS_FEATURE_BIDI_BRACKETS: Type = 1;
    #[doc = " When this feature is disabled, text is split into VSFilter-compatible\n segments and text in each segment is processed in isolation.\n Notably, this includes running the Unicode Bidirectional\n Algorithm and shaping the text within each run separately.\n The individual runs are then laid out left-to-right,\n even if they contain right-to-left text.\n\n When this feature is enabled, each event's text is processed as a whole\n (as far as possible). In particular, the Unicode Bidirectional\n Algorithm is run on the whole text, and text is shaped across\n override tags.\n\n This is incompatible with VSFilter and disabled by default.\n\n libass extensions to ASS such as Encoding -1 can cause individual\n events to be always processed as if this feature is enabled."]
    pub const ASS_FEATURE_WHOLE_TEXT_LAYOUT: Type = 2;
    #[doc = " Break lines according to the Unicode Line Breaking Algorithm.\n If the track language is set, some additional language-specific tweaks\n may be applied. Setting this enables more breaking opportunities\n compared to classic ASS. However, it is still possible for long words\n without breaking opportunities to cause overfull lines.\n This is incompatible with VSFilter and disabled by default.\n\n This feature may be unavailable at runtime if\n libass was compiled without libunibreak support."]
    pub const ASS_FEATURE_WRAP_UNICODE: Type = 3;
}
extern "C" {
    #[doc = " \\brief Initialize the library.\n \\return library handle or NULL if failed"]
    pub fn ass_library_init() -> *mut ASS_Library;
}
extern "C" {
    #[doc = " \\brief Finalize the library\n \\param priv library handle"]
    pub fn ass_library_done(priv_: *mut ASS_Library);
}
extern "C" {
    #[doc = " \\brief Set additional fonts directory.\n Optional directory that will be scanned for fonts.  The fonts\n found are used for font lookup.\n NOTE: A valid font directory is not needed to support embedded fonts.\n On Microsoft Windows, when using WIN32-APIs, fonts_dir must be in either\n UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8\n or the encoding accepted by fopen with the former taking precedence\n if both versions are valid and exist.\n On all other systems there is no need for special considerations like that.\n\n \\param priv library handle\n \\param fonts_dir directory with additional fonts"]
    pub fn ass_set_fonts_dir(priv_: *mut ASS_Library, fonts_dir: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Whether fonts should be extracted from track data.\n \\param priv library handle\n \\param extract whether to extract fonts"]
    pub fn ass_set_extract_fonts(priv_: *mut ASS_Library, extract: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Register style overrides with a library instance.\n The overrides should have the form [Style.]Param=Value, e.g.\n   SomeStyle.Font=Arial\n   ScaledBorderAndShadow=yes\n\n \\param priv library handle\n \\param list NULL-terminated list of strings"]
    pub fn ass_set_style_overrides(priv_: *mut ASS_Library, list: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Explicitly process style overrides for a track.\n \\param track track handle"]
    pub fn ass_process_force_style(track: *mut ASS_Track);
}
extern "C" {
    #[doc = " \\brief Register a callback for debug/info messages.\n If a callback is registered, it is called for every message emitted by\n libass.  The callback receives a format string and a list of arguments,\n to be used for the printf family of functions. Additionally, a log level\n from 0 (FATAL errors) to 7 (verbose DEBUG) is passed.  Usually, level 5\n should be used by applications.\n If no callback is set, all messages level < 5 are printed to stderr,\n prefixed with [ass].\n\n \\param priv library handle\n \\param msg_cb pointer to callback function\n \\param data additional data, will be passed to callback"]
    pub fn ass_set_message_cb(
        priv_: *mut ASS_Library,
        msg_cb: ::std::option::Option<
            unsafe extern "C" fn(
                level: ::std::os::raw::c_int,
                fmt: *const ::std::os::raw::c_char,
                args: va_list,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Initialize the renderer.\n \\param priv library handle\n \\return renderer handle or NULL if failed\n\n NOTE: before rendering starts the renderer should also be\n       configured with at least ass_set_storage_size(),\n       ass_set_frame_size() and ass_set_fonts();\n       see respective docs."]
    pub fn ass_renderer_init(arg1: *mut ASS_Library) -> *mut ASS_Renderer;
}
extern "C" {
    #[doc = " \\brief Finalize the renderer.\n \\param priv renderer handle"]
    pub fn ass_renderer_done(priv_: *mut ASS_Renderer);
}
extern "C" {
    #[doc = " \\brief Set the frame size in pixels, including margins.\n The renderer will never return images that are outside of the frame area.\n The value set with this function can influence the pixel aspect ratio used\n for rendering.\n If after compensating for configured margins the frame size\n is not an isotropically scaled version of the video display size,\n you may have to use ass_set_pixel_aspect().\n @see ass_set_pixel_aspect()\n @see ass_set_margins()\n \\param priv renderer handle\n \\param w width\n \\param h height\n\n NOTE: frame size must be configured before an ASS_Renderer can be used."]
    pub fn ass_set_frame_size(
        priv_: *mut ASS_Renderer,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set the source image size in pixels.\n This affects some ASS tags like e.g. 3D transforms and\n is used to calculate the source aspect ratio and blur scale.\n If subtitles specify valid LayoutRes* headers, those will take precedence.\n The source image size can be reset to default by setting w and h to 0.\n The value set with this function can influence the pixel aspect ratio used\n for rendering.\n The values must be the actual storage size of the video stream,\n without any anamorphic de-squeeze applied.\n @see ass_set_pixel_aspect()\n \\param priv renderer handle\n \\param w width\n \\param h height\n\n NOTE: storage size must be configured to get correct results,\n       otherwise libass is forced to make a fallible guess."]
    pub fn ass_set_storage_size(
        priv_: *mut ASS_Renderer,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set shaping level. This is merely a hint, the renderer will use\n whatever is available if the request cannot be fulfilled.\n \\param level shaping level"]
    pub fn ass_set_shaper(priv_: *mut ASS_Renderer, level: ASS_ShapingLevel::Type);
}
extern "C" {
    #[doc = " \\brief Set frame margins.  These values may be negative if pan-and-scan\n is used. The margins are in pixels. Each value specifies the distance from\n the video rectangle to the renderer frame. If a given margin value is\n positive, there will be free space between renderer frame and video area.\n If a given margin value is negative, the frame is inside the video, i.e.\n the video has been cropped.\n\n The renderer will try to keep subtitles inside the frame area. If possible,\n text is layout so that it is inside the cropped area. Subtitle events\n that can't be moved are cropped against the frame area.\n\n ass_set_use_margins() can be used to allow libass to render subtitles into\n the empty areas if margins are positive, i.e. the video area is smaller than\n the frame. (Traditionally, this has been used to show subtitles in\n the bottom \"black bar\" between video bottom screen border when playing 16:9\n video on a 4:3 screen.)\n\n \\param priv renderer handle\n \\param t top margin\n \\param b bottom margin\n \\param l left margin\n \\param r right margin"]
    pub fn ass_set_margins(
        priv_: *mut ASS_Renderer,
        t: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        l: ::std::os::raw::c_int,
        r: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Whether margins should be used for placing regular events.\n \\param priv renderer handle\n \\param use whether to use the margins"]
    pub fn ass_set_use_margins(priv_: *mut ASS_Renderer, use_: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Set pixel aspect ratio correction.\n This is the ratio of pixel width to pixel height.\n\n Generally, this is (d_w / d_h) / (s_w / s_h), where s_w and s_h is the\n video storage size, and d_w and d_h is the video display size. (Display\n and storage size can be different for anamorphic video, such as DVDs.)\n\n If the pixel aspect ratio is 0, or if the aspect ratio has never been set\n by calling this function, libass will calculate a default pixel aspect ratio\n out of values set with ass_set_frame_size() and ass_set_storage_size(). Note\n that this default assumes the frame size after compensating for margins\n corresponds to an isotropically scaled version of the video display size.\n If the storage size has not been set, a pixel aspect ratio of 1 is assumed.\n\n If subtitles specify valid LayoutRes* headers, the API-configured\n pixel aspect value is discarded in favour of one calculated out of the\n headers and values set with ass_set_frame_size().\n\n \\param priv renderer handle\n \\param par pixel aspect ratio (1.0 means square pixels, 0 means default)"]
    pub fn ass_set_pixel_aspect(priv_: *mut ASS_Renderer, par: f64);
}
extern "C" {
    #[doc = " \\brief Set aspect ratio parameters.\n This calls ass_set_pixel_aspect(priv, dar / sar).\n @deprecated New code should use ass_set_pixel_aspect().\n \\param priv renderer handle\n \\param dar display aspect ratio (DAR), prescaled for output PAR\n \\param sar storage aspect ratio (SAR)"]
    pub fn ass_set_aspect_ratio(priv_: *mut ASS_Renderer, dar: f64, sar: f64);
}
extern "C" {
    #[doc = " \\brief Set a fixed font scaling factor.\n \\param priv renderer handle\n \\param font_scale scaling factor, default is 1.0"]
    pub fn ass_set_font_scale(priv_: *mut ASS_Renderer, font_scale: f64);
}
extern "C" {
    #[doc = " \\brief Set font hinting method.\n \\param priv renderer handle\n \\param ht hinting method"]
    pub fn ass_set_hinting(priv_: *mut ASS_Renderer, ht: ASS_Hinting::Type);
}
extern "C" {
    #[doc = " \\brief Set line spacing. Will not be scaled with frame size.\n \\param priv renderer handle\n \\param line_spacing line spacing in pixels"]
    pub fn ass_set_line_spacing(priv_: *mut ASS_Renderer, line_spacing: f64);
}
extern "C" {
    #[doc = " \\brief Set vertical line position.\n \\param priv renderer handle\n \\param line_position vertical line position of subtitles in percent\n (0-100: 0 = on the bottom (default), 100 = on top)"]
    pub fn ass_set_line_position(priv_: *mut ASS_Renderer, line_position: f64);
}
extern "C" {
    #[doc = " \\brief Get the list of available font providers. The output array\n is allocated with malloc and can be released with free(). If an\n allocation error occurs, size is set to (size_t)-1.\n \\param priv library handle\n \\param providers output, list of default providers (malloc'ed array)\n \\param size output, number of providers\n \\return list of available font providers (user owns the returned array)"]
    pub fn ass_get_available_font_providers(
        priv_: *mut ASS_Library,
        providers: *mut *mut ASS_DefaultFontProvider::Type,
        size: *mut usize,
    );
}
extern "C" {
    #[doc = " \\brief Set font lookup defaults.\n \\param default_font path to default font to use. Must be supplied if\n all system fontproviders are disabled or unavailable.\n \\param default_family fallback font family, or NULL\n \\param dfp which font provider to use (one of ASS_DefaultFontProvider). In\n older libass version, this could be 0 or 1, where 1 enabled fontconfig.\n Newer relases also accept 0 (ASS_FONTPROVIDER_NONE) and 1\n (ASS_FONTPROVIDER_AUTODETECT), which is almost backward-compatible.\n If the requested fontprovider does not exist or fails to initialize, the\n behavior is the same as when ASS_FONTPROVIDER_NONE was passed.\n \\param config path to fontconfig configuration file, or NULL.  Only relevant\n if fontconfig is used. The encoding must match the one accepted by fontconfig.\n \\param update whether fontconfig cache should be built/updated now.  Only\n relevant if fontconfig is used.\n\n NOTE: font lookup must be configured before an ASS_Renderer can be used."]
    pub fn ass_set_fonts(
        priv_: *mut ASS_Renderer,
        default_font: *const ::std::os::raw::c_char,
        default_family: *const ::std::os::raw::c_char,
        dfp: ::std::os::raw::c_int,
        config: *const ::std::os::raw::c_char,
        update: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set selective style override mode.\n If enabled, the renderer attempts to override the ASS script's styling of\n normal subtitles, without affecting explicitly positioned text. If an event\n looks like a normal subtitle, parts of the font style are copied from the\n user style set with ass_set_selective_style_override().\n Warning: the heuristic used for deciding when to override the style is rather\n          rough, and enabling this option can lead to incorrectly rendered\n          subtitles. Since the ASS format doesn't have any support for\n          allowing end-users to customize subtitle styling, this feature can\n          only be implemented on \"best effort\" basis, and has to rely on\n          heuristics that can easily break.\n \\param priv renderer handle\n \\param bits bit mask comprised of ASS_OverrideBits values."]
    pub fn ass_set_selective_style_override_enabled(
        priv_: *mut ASS_Renderer,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set style for selective style override.\n See ass_set_selective_style_override_enabled().\n \\param style style settings to use if override is enabled. Applications\n should initialize it with {0} before setting fields. Strings will be copied\n by the function."]
    pub fn ass_set_selective_style_override(priv_: *mut ASS_Renderer, style: *mut ASS_Style);
}
extern "C" {
    #[doc = " \\brief This is a stub and does nothing. Old documentation: Update/build font\n cache.  This needs to be called if it was disabled when ass_set_fonts was set.\n\n \\param priv renderer handle\n \\return success"]
    pub fn ass_fonts_update(priv_: *mut ASS_Renderer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set hard cache limits.  Do not set, or set to zero, for reasonable\n defaults.\n\n \\param priv renderer handle\n \\param glyph_max maximum number of cached glyphs\n \\param bitmap_max_size maximum bitmap cache size (in MB)"]
    pub fn ass_set_cache_limits(
        priv_: *mut ASS_Renderer,
        glyph_max: ::std::os::raw::c_int,
        bitmap_max_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Render a frame, producing a list of ASS_Image.\n \\param priv renderer handle\n \\param track subtitle track\n \\param now video timestamp in milliseconds\n \\param detect_change compare to the previous call and set to 1\n if positions may have changed, or set to 2 if content may have changed."]
    pub fn ass_render_frame(
        priv_: *mut ASS_Renderer,
        track: *mut ASS_Track,
        now: ::std::os::raw::c_longlong,
        detect_change: *mut ::std::os::raw::c_int,
    ) -> *mut ASS_Image;
}
extern "C" {
    #[doc = " \\brief Allocate a new empty track object.\n \\param library handle\n \\return pointer to empty track or NULL on failure"]
    pub fn ass_new_track(arg1: *mut ASS_Library) -> *mut ASS_Track;
}
extern "C" {
    #[doc = " \\brief Enable or disable certain features\n This manages flags that control the behavior of the renderer and how certain\n tags etc. within the track are interpreted. The defaults on a newly created\n ASS_Track are such that rendering is compatible with traditional renderers\n like VSFilter, and/or old versions of libass. Calling ass_process_data() or\n ass_process_codec_private() may change some of these flags according to file\n headers. (ass_process_chunk() will not change any of the flags.)\n Additions to ASS_Feature are backward compatible to old libass releases (ABI\n compatibility).\n After calling ass_render_frame, changing features is no longer allowed.\n \\param track track\n \\param feature the specific feature to enable or disable\n \\param enable 0 for disable, any non-0 value for enable\n \\return 0 if feature set, -1 if feature is unknown"]
    pub fn ass_track_set_feature(
        track: *mut ASS_Track,
        feature: ASS_Feature::Type,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deallocate track and all its child objects (styles and events).\n \\param track track to deallocate or NULL"]
    pub fn ass_free_track(track: *mut ASS_Track);
}
extern "C" {
    #[doc = " \\brief Allocate new style.\n \\param track track\n \\return newly allocated style id >= 0, or a value < 0 on failure\n See GENERAL NOTE in ass_types.h."]
    pub fn ass_alloc_style(track: *mut ASS_Track) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate new event.\n \\param track track\n \\return newly allocated event id >= 0, or a value < 0 on failure\n See GENERAL NOTE in ass_types.h."]
    pub fn ass_alloc_event(track: *mut ASS_Track) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete a style.\n \\param track track\n \\param sid style id\n Deallocates style data. Does not modify track->n_styles.\n Freeing a style without subsequently setting track->n_styles\n to a value less than or equal to the freed style id before calling\n any other libass API function on the track is undefined behaviour.\n Additionally a freed style style still being referenced by an event\n in track->events will also result in undefined behaviour.\n See GENERAL NOTE in ass_types.h."]
    pub fn ass_free_style(track: *mut ASS_Track, sid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Delete an event.\n \\param track track\n \\param eid event id\n Deallocates event data. Does not modify track->n_events.\n Freeing an event without subsequently setting track->n_events\n to a value less than or equal to the freed event id before calling\n any other libass API function on the track is undefined behaviour.\n See GENERAL NOTE in ass_types.h"]
    pub fn ass_free_event(track: *mut ASS_Track, eid: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Parse a chunk of subtitle stream data.\n \\param track track\n \\param data string to parse\n \\param size length of data"]
    pub fn ass_process_data(
        track: *mut ASS_Track,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Parse Codec Private section of the subtitle stream, in Matroska\n format.  See the Matroska specification for details.\n \\param track target track\n \\param data string to parse\n \\param size length of data"]
    pub fn ass_process_codec_private(
        track: *mut ASS_Track,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Parse a chunk of subtitle stream data. A chunk contains exactly one\n event in Matroska format.  See the Matroska specification for details.\n In later libass versions (since LIBASS_VERSION==0x01300001), using this\n function means you agree not to modify events manually, or using other\n functions manipulating the event list like ass_process_data(). If you do\n anyway, the internal duplicate checking might break. Calling\n ass_flush_events() is still allowed.\n \\param track track\n \\param data string to parse\n \\param size length of data\n \\param timecode starting time of the event (milliseconds)\n \\param duration duration of the event (milliseconds)"]
    pub fn ass_process_chunk(
        track: *mut ASS_Track,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        timecode: ::std::os::raw::c_longlong,
        duration: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    #[doc = " \\brief Set whether the ReadOrder field when processing a packet with\n ass_process_chunk() should be used for eliminating duplicates.\n \\param check_readorder 0 means do not try to eliminate duplicates; 1 means\n use the ReadOrder field embedded in the packet as unique identifier, and\n discard the packet if there was already a packet with the same ReadOrder.\n Other values are undefined.\n If this function is not called, the default value is 1."]
    pub fn ass_set_check_readorder(track: *mut ASS_Track, check_readorder: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Flush buffered events.\n \\param track track"]
    pub fn ass_flush_events(track: *mut ASS_Track);
}
extern "C" {
    #[doc = " \\brief Read subtitles from file.\n \\param library library handle\n \\param fname file name\n \\param codepage encoding (iconv format)\n \\return newly allocated track or NULL on failure\n NOTE: On Microsoft Windows, when using WIN32-APIs, fname must be in either\n UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8\n or the encoding accepted by fopen with the former taking precedence\n if both versions are valid and exist.\n On all other systems there is no need for special considerations like that."]
    pub fn ass_read_file(
        library: *mut ASS_Library,
        fname: *mut ::std::os::raw::c_char,
        codepage: *mut ::std::os::raw::c_char,
    ) -> *mut ASS_Track;
}
extern "C" {
    #[doc = " \\brief Read subtitles from memory.\n \\param library library handle\n \\param buf pointer to subtitles text\n \\param bufsize size of buffer\n \\param codepage encoding (iconv format)\n \\return newly allocated track or NULL on failure"]
    pub fn ass_read_memory(
        library: *mut ASS_Library,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        codepage: *mut ::std::os::raw::c_char,
    ) -> *mut ASS_Track;
}
extern "C" {
    #[doc = " \\brief Read styles from file into already initialized track.\n \\param fname file name\n \\param codepage encoding (iconv format)\n \\return 0 on success\n NOTE: On Microsoft Windows, when using WIN32-APIs, fname must be in either\n UTF-8 mixed with lone or paired UTF-16 surrogates encoded like in CESU-8\n or the encoding accepted by fopen with the former taking precedence\n if both versions are valid and exist.\n On all other systems there is no need for special considerations like that."]
    pub fn ass_read_styles(
        track: *mut ASS_Track,
        fname: *mut ::std::os::raw::c_char,
        codepage: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add a memory font.\n \\param library library handle\n \\param name attachment name\n \\param data binary font data\n \\param data_size data size"]
    pub fn ass_add_font(
        library: *mut ASS_Library,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        data_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Remove all fonts stored in an ass_library object.\n This can only be called safely if all ASS_Track and ASS_Renderer instances\n associated with the library handle have been released first.\n \\param library library handle"]
    pub fn ass_clear_fonts(library: *mut ASS_Library);
}
extern "C" {
    #[doc = " \\brief Calculates timeshift from now to the start of some other subtitle\n event, depending on movement parameter.\n \\param track subtitle track\n \\param now current time in milliseconds\n \\param movement how many events to skip from the one currently displayed\n +2 means \"the one after the next\", -1 means \"previous\"\n \\return timeshift in milliseconds"]
    pub fn ass_step_sub(
        track: *mut ASS_Track,
        now: ::std::os::raw::c_longlong,
        movement: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
